<!-- 
 * 3DCityDB-Web-Map
 * http://www.3dcitydb.org/
 * 
 * Copyright 2015 - 2016
 * Chair of Geoinformatics
 * Technical University of Munich, Germany
 * https://www.gis.bgu.tum.de/
 * 
 * The 3DCityDB-Web-Map is jointly developed with the following
 * cooperation partners:
 * 
 * virtualcitySYSTEMS GmbH, Berlin <http://www.virtualcitysystems.de/>
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version (or Chrome Frame if pre-IE11). -->
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <link rel="icon" type="image/png" href="./../theme/img/favicon.png" sizes="16x16">
  <title>New York City demo</title>
  
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src="./ThirdParty/Cesium/Cesium.js"></script> 
  <script src="./ThirdParty/Intersection/IntersectionAPI.js"></script>
  <script src="./js/3dcitydb-web-map.js"></script>  
  <script src="./js/CitydbUtil.js"></script>  
  <script src="./js/CitydbWebworker.js"></script>
  <script src="./js/CitydbSceneTransforms.js"></script> 
  <script src="./js/CitydbKmlHighlightingManager.js"></script>   
  <script src="./js/CitydbKmlTilingManager.js"></script>  
  <script src="./js/CitydbKmlDataSource.js"></script>    
  <script src="./js/CitydbKmlLayer.js"></script> 
<!--   <script src= "./js/d3.js"></script>
 -->  <script src= "./js/geotiff.js"></script>
  <script src= "./js/jquery.js"></script>
<!--   <script src= "./js/proj4.js"></script>
 -->    
  <style>
     @import url(./ThirdParty/Cesium/Widgets/widgets.css);
      html, body, #cesiumContainer {
          top: 0px;
          left: 0px;
          position: absolute;
          width: 100%;
          height: 100%;
          margin: 0;
          padding: 0;
          overflow: hidden;
          z-index: -1;
      }
      #uiMenu {
          border-radius:5px;
          padding: 10px;
          position:absolute;
          left: 20px;
          font-family: "Arial";
          z-index: 99999;
      }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
   <div id="uiMenu">
   <!--  <button type="button" onclick="addgltfLayers()">add waterbody gltf Layer</button>
    <button type="button" onclick="addkmlLayers()">add waterbody kml Layer</button> -->
     <span>Time Controls: </span><button id="getPrevius" style="margin-top: 5px;">Backward</button> <button id="getNext" style="margin-top: 5px;">Forward</button></br>

  </div>
  <script>
	Cesium.BingMapsApi.defaultKey = 'ApOW9LMkerqWIVSnFauilSeaZyp8df66byy1USCTjgTdMvhb4y1iAhEsUHQfCgzq'
	       
    var s = 51.139942;
    var n = 51.143203;
    var w = 7.366514;
    var e = 7.373476;
  
	var viewer = new Cesium.Viewer('cesiumContainer', {
	   //   terrainExaggeration : 2.0

	});
	var extent = new Cesium.Rectangle.fromDegrees(w,s,e,n);
	viewer.camera.setView({destination: extent})
	
	var webMap = new WebMap3DCityDB(viewer);
	webMap.activateViewChangedEvent(true);
	var scene = viewer.scene;
 
  
var positionN=[];
var ellipsoid = Cesium.Ellipsoid.WGS84;
var idList=[];
 
 viewer.flyTo(
    viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/roadal.kml', {
                  })
    ))
  viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/betrieb.kml', {
           
        })
    )
     viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/doc.kml', {
           
        })
    )
     viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/pegel.kml', {
          
        })
    )
      
      
      
  viewer.scene.globe.depthTestAgainstTerrain = false;
  viewer.scene.globe.showWaterEffect =true;
	 
    var terrainProvider = new Cesium.CesiumTerrainProvider({
     url: 'http://localhost/dashboard/cesium/Apps/terraincop'    

 //   url : '//assets.agi.com/stk-terrain/world'
    ,  requestVertexNormals : true  
 
    });
     viewer.terrainProvider = terrainProvider;


    
  

 
 // createCzml() ;
 
var start = Cesium.JulianDate.fromIso8601("2016-02-01T00:00:00Z");
//var stop = Cesium.JulianDate.addSeconds(start, 360, new Cesium.JulianDate());
 var stop = Cesium.JulianDate.fromIso8601("2016-02-27T00:00:00Z");
 var middle = Cesium.JulianDate.fromIso8601("2016-02-15T00:00:00Z");
 
//Make sure viewer is at the desired time.
 viewer.clock.startTime = middle.clone();
 viewer.clock.stopTime = stop.clone();
 viewer.clock.currentTime = start.clone();
 viewer.clock.ClockStep = 1;
 
 viewer.clock.multiplier = 50;
 viewer.timeline.zoomTo(start, stop);
 

 czml = './data/simple.czml';
 Cesium.CzmlDataSource.updaters.push(czmlUpdater);

var czmldataSource = Cesium.CzmlDataSource.load(czml);

viewer.dataSources.add(czmldataSource).then(function(data){

var a =positionN.length

        
    var promis = Cesium.sampleTerrain(viewer.terrainProvider, 17, positionN);
        promis.then(function(terrainSamplePositions){ 
            var entities= data.entities;
             for (var i = 0; i < terrainSamplePositions.length; ++i) {
                var BaseHeight = terrainSamplePositions[i].height;//.toFixed(2);
            //         console.log(BaseHeight)

                var entity = entities.getById(idList[i]);
                var cartesianOld = entity.position._value ;       
 //entity.position.getValue( currentTime);        
                var cartesianOldToCartography= ellipsoid.cartesianToCartographic(cartesianOld);
                //var newHeight2 = BaseHeight +1* cartesianOldToCartography.height
                var newHeight2 = 290+ cartesianOldToCartography.height
          //      console.log(parseFloat(cartesianOldToCartography.height).toFixed(4))
                 entity.position.setValue(Cesium.Cartesian3.fromRadians(cartesianOldToCartography.longitude,cartesianOldToCartography.latitude,newHeight2));
             
       
   
            }
 
        });
 
}) ;
 
 //node transformation of the model 
 /// change position of the model 

  var rasterset = [["2016-02-01T00:00:00Z/2016-02-02T00:00:00Z","1feb"],["2016-02-15T00:00:00Z/2016-02-16T00:00:00Z","28feb"],["2016-02-26T00:00:00Z/2016-02-27T00:00:00Z","1sep"]];
   
   var  i=1 ; 
 $('#getNext').on('click',function() {
	   
        if(i<rasterset.length-1){ i++ ;       
  callRaster(rasterset[i])
  }
   
	});
 $('#getPrevius').on('click',function() {
	    
 if(i>0){ i--  
      callRaster(rasterset[i])
}
	});
    
   
   
   
   
   
   
  var settings = {
  "async": true,
  "crossDomain": true,
  "url": "http://tamis.dev.52north.org/tamis-rest/api/v1/services/1/processes/org.n52.wps.server.r.tamis-interpolation",
  "method": "POST",
  "headers": {
    "content-type": "application/json",
    "cache-control": "no-cache",
    "postman-token": "84c891ed-f8c6-6922-fbe3-64e886456b0b"
  },
  "processData": false,
  "data": "{\r\n    \"inputs\": [\r\n        {\r\n            \"id\": \"sosInputData\",\r\n            \"value\": \r\n\"http://fluggs.wupperverband.de/sos2-tamis/service?service%3DSOS&version%3D2.0.0&request%3DGetObservation&responseformat%3Dhttp://www.opengis.net/om/2.0&observedProperty%3DSchuettmenge&procedure%3DTageswert_Prozessleitsystem&namespaces%3Dxmlns%28sams%2Chttp%3A%2F%2Fwww.opengis.net%2FsamplingSpatial%2F2.0%29%2Cxmlns%28om%2Chttp%3A%2F%2Fwww.opengis.net%2Fom%2F2.0%29&temporalFilter%3Dom%3AphenomenonTime%2C2016-02-01T09:59:01.00Z%2F2016-02-02T23:59:01.00Z\",\r\n            \"type\" : \"text/plain\"\r\n        },\r\n        {\r\n            \"id\": \"target\",\r\n            \"value\" \r\n:\"https://github.com/52North/tamis/raw/master/geotiff.tiff\",\r\n            \"type\" : \"application/geotiff\"\r\n        }\r\n    ],\r\n    \"outputs\": [\r\n     \r\n      {\r\n              \"id\": \"predictions\",\r\n              \"type\": \"application/geotiff\"\r\n       }\r\n    ]\r\n}"
}

$.ajax(settings).done(function (response) {
  console.log(response);
}); 
   
   
   
   
   
   
   
   
   
   
   
    // on time change
viewer.clock.onTick.addEventListener(function(clock) {
    var entity = viewer.selectedEntity;
 
 //console.log(clock.currentTime,middle)
    if (Cesium.defined(entity)    ) {
  //   viewer.trackedEntity = entity
    var dataSources = viewer.dataSources;
   // console.log(dataSources)
    console.log(entity.model.nodeTransformations.Y_UP_Transform.translation.intervals._intervals
);
   
 
}
 
 
    
});

function callRaster (rastername){
var timeInterval = new Cesium.TimeInterval.fromIso8601({
iso8601 : rastername[0]

})
 
    viewer.clock.currentTime =  timeInterval.start;
     for(var x=0; x<viewer.dataSources.length;x++){
        var source = viewer.dataSources.get(x);
  //      var dateToCheck = Cesium.JulianDate.fromIso8601(rastername[0]);
       var dateToCheck =  timeInterval.start;
        var entities = source.entities.values

        if (source.name == "CZML" && entities &&  Cesium.TimeInterval.contains(entities[0].model.nodeTransformations.Y_UP_Transform.translation.intervals, dateToCheck)  ){
          break 
         } else if (source.name == "CZML" && entities  &&  !Cesium.TimeInterval.contains(entities[0].model.nodeTransformations.Y_UP_Transform.translation.intervals, dateToCheck)){
 
 
          Cesium.loadWithXhr({
    url : './data/'+ rastername[1]+'.tif',
    responseType : 'arraybuffer'
}).then( function(response){

loadRasterToMap(response,timeInterval )

} ).otherwise(function(error) { console.log(error);
    // an error occurred
})
        }
        
        
           
    }
    
         
         
 

}

// call raster for a time and apply to map 
function loadRasterToMap (response,timeInterval) {
       var rasterdata=  geotif(response);
   // console.log(rasterdata);
    var dataSources = viewer.dataSources;
 
     hash=[];
 
    var w1 = Math.floor(rasterdata[2][1]);
    var h1 = Math.floor(rasterdata[2][0]);
 
    var w2 = Math.round(rasterdata[2][1]/(10));
    var h2 = Math.round(rasterdata[2][0]/(10));
     var x_ratio=w1/w2
    var    y_ratio=h1/h2; 
    console.log(w1,w2,h1,h2)
    console.log(timeInterval)
    for (var i=0;i<h2;i++){
                for(var j=0;j<w2;j++){
                var px = Math.floor(j*x_ratio) ;
                var py = Math.floor(i*y_ratio) ;
     
                hash[parseInt((i*w2)+j)] = rasterdata[0][1][(py*w1)+px];
                var cellOnOrigin = (i*w2)+j
                var id = String(cellOnOrigin);
                var czmlEntities =     dataSources.get(0).entities;
                     if( czmlEntities &&  czmlEntities.getById(id) ){
                        var entity = czmlEntities.getById(id);
                        var averageHeight = rasterdata[0][1][(py*w1)+px]
                        var color =  setColor(averageHeight);
                         timeInterval.data = new Cesium.Cartesian3(0,0,averageHeight*2)
                   //     var interval = new Cesium.TimeInterval.fromIso8601({
                   //        iso8601 : RasterTime  ,
                       
                    //        data: new Cesium.Cartesian3(0,0,averageHeight) // averageHeight
                    //    }); 
                   var colorInterval =  Cesium.TimeInterval.clone(timeInterval);
                   colorInterval.data = color
                           
                  //      console.log(entity.model)
                        entity.model.nodeTransformations.Y_UP_Transform.translation.intervals.addInterval(timeInterval)   ;
                         entity.model.color.intervals.addInterval(colorInterval)   ;
                       // entity.model.nodeTransformations.Y_UP_Transform.translation = (new Cesium.Cartesian3(0,0,averageHeight) ) ;
                    //    entity.model.color = color
                // console.log( entity.model.color)

                    }   
                }
        }  
                          
     
   
}
//add color to any czml loaded 
  function czmlUpdater(dynamicObject, packet, dynamicObjectCollection, sourceUri) {
        var height = packet.position.cartographicDegrees[2]
      var height2 = packet.model.nodeTransformations.Y_UP_Transform.translation.cartesian[2];
      packet.model.nodeTransformations.Y_UP_Transform.translation.cartesian[2]=  height ;
      
     packet.model.nodeTransformations.Y_UP_Transform.translation = [{ 
							"interval": "2016-02-15T00:00:00Z/2016-02-16T16:30:00Z",
							"cartesian": [0, 0,   packet.position.cartographicDegrees[2]*2]
						} ]
  //    console.log( packet.model.nodeTransformations.Y_UP_Transform)
        var color =  setColor(height);
         color= {"rgba": [255*color.red,255*color.green ,255*color.blue,255* color.alpha]} ;
        
     //   packet.model.color =  color;
        packet.model.color =  [{ 
							"interval": "2016-02-15T00:00:00Z/2016-02-16T16:30:00Z",
							"rgba": color.rgba
						} ];
        currentPosition = packet.position.cartographicDegrees;
        packet.position.cartographicDegrees = [ currentPosition[0], currentPosition[1],0]
        positionN.push(  new Cesium.Cartographic(Cesium.Math.toRadians(  currentPosition[0]), Cesium.Math.toRadians( currentPosition[1]) ));
        idList.push(packet.id);
      
    }



  function createCzml(){     
     var czml = [{
        "id" : "document",
        "name" : "CZML Point",
        "version" : "1.0"  }];
     var kmlPath = "https://raw.githubusercontent.com/amir-ba/WaterBody-Visualization-/master/HTML5Application/public_html/data/waterbody/Tiles/0/0/pigel_Tile_0_0_collada.kml";
     var kmlFolder= kmlPath.replace(/\/[^\/]+$/, '');
        
    $.get(kmlPath, function(data){

        $(data).find("Placemark").each(function(index, value){
            var that =$(this);
            var id = that.attr( "id" );
            var name = that.find( "name" ).text();
            
            var regex= /\d+(?=_)/ig ;
            var reg = regex.exec(name);
            var cellId =reg ? reg[0]: name; 
            
          
            var locationNode= that.find( "Location" );
            var location = [parseFloat(locationNode.find( "longitude" ).text()),parseFloat(locationNode.find( "latitude" ).text()),parseFloat(locationNode.find( "altitude" ).text())];
            var path =  that.find( "href" ).text();
            if (id){
            
                var packet =  {
                            "id":  cellId,
                            "name": name,
                            "position": {
                                "cartographicDegrees": location
                            },
                            "model": {
                                "gltf": kmlFolder +"/"+path ,
                                "colorBlendModes": "Replace",
                                "colorBlendAmount": 1 ,
                                "nodeTransformations": { 
                                    "Y_UP_Transform": {
                                            "translation": [{
                                                  "interval" : "2016-02-15T16:00:00Z/2016-02-24T16:30:00Z" , 
                                                
                                                
                                                "cartesian":[0,0,0]
                                               
                                            
                                                   } ]
                                    }
                                }
                                
                            }               
                } 
                czml.push(packet);
            
            }
        });
 console.log(JSON.stringify(czml));

   return czml;
   
    
});
}
 

function setColor(height,startHeight,intervals,cssColorArray){
  if(!cssColorArray){cssColorArray =  ["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#f7f7f7","#d1e5f0","#92c5de","#4393c3","#2166ac","#053061","#050861"];  }
  if(!intervals){var interval = 0.03 }
  if(!startHeight){var startHeight = 0.01  }

   // var startHeight= heightIntervals[0];
  //  var interval = heightIntervals[1];
 //   var endHeight= heightIntervals[2];
    var rangeIndex;
    if  ( height<=startHeight){
                rangeIndex =11;
            }else if (height >startHeight && height<=(startHeight+1*interval) ){
                rangeIndex =10;
            }else if (height >(0.03) && height<=(0.05) ){
                rangeIndex =9;
            }else if (height >(0.05)  && height<=(0.06 )){
                rangeIndex =8;
            }else if (height >(0.06)  && height<=(0.08)  ){
                rangeIndex =7;
            }else if (height >(0.08)  && height<=(1)  ){
                rangeIndex =6;
            }else if (height >(1)  && height<=(1.1)  ){
                rangeIndex =5;
            } else if (height >(1)  && height<=(1.5)  ){
                rangeIndex =4;
            }else if (height >(1.5)  && height<=(2)  ){
                rangeIndex =3;
            }else if (height >(2)  && height<=(2.5)  ){
                rangeIndex =2;
            }else if (height >(2.5)  && height<=(3)  ){
                rangeIndex =1;
            }
            else if (height >(3)  ){
                rangeIndex =0;
            }
    var color= new Cesium.Color.fromCssColorString(cssColorArray[rangeIndex]);
 //   console.log(rangeIndex)
    return color;
}

 
  
  function geotif(RR){
 
 
    var tiff = GeoTIFF.parse(RR);
    var image = tiff.getImage();

    var rasters= image.readRasters();
    var tiepoint = image.getTiePoints()[0];
    var pixelScale = image.getFileDirectory().ModelPixelScale;
    var geoTransform = [tiepoint.x, pixelScale[0], 0, tiepoint.y, 0, -1*pixelScale[1]];
    var height = image.getHeight() //geoTransform[1];
    var width = Math.abs( image.getWidth())///geoTransform[5]);
    var invGeoTransform = [-geoTransform[
    0]/geoTransform[1], 1/geoTransform[1],0,-geoTransform[3]/geoTransform[5],0,1/geoTransform[5]];
 return [rasters,geoTransform,[height,width]]
 
 }
 
 
</script>
</body>
</html>
