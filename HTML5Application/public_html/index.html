<!-- 
 * 3DCityDB-Web-Map
 * http://www.3dcitydb.org/
 * 
 * Copyright 2015 - 2016
 * Chair of Geoinformatics
 * Technical University of Munich, Germany
 * https://www.gis.bgu.tum.de/
 * 
 * The 3DCityDB-Web-Map is jointly developed with the following
 * cooperation partners:
 * 
 * virtualcitySYSTEMS GmbH, Berlin <http://www.virtualcitysystems.de/>
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version (or Chrome Frame if pre-IE11). -->
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <link rel="icon" type="image/png" href="./../theme/img/favicon.png" sizes="16x16">
  <title>New York City demo</title>
  
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src="./ThirdParty/Cesium/Cesium.js"></script> 
  <script src="./ThirdParty/Intersection/IntersectionAPI.js"></script>
  <script src="./js/3dcitydb-web-map.js"></script>  
  <script src="./js/CitydbUtil.js"></script>  
  <script src="./js/CitydbWebworker.js"></script>
  <script src="./js/CitydbSceneTransforms.js"></script> 
  <script src="./js/CitydbKmlHighlightingManager.js"></script>   
  <script src="./js/CitydbKmlTilingManager.js"></script>  
  <script src="./js/CitydbKmlDataSource.js"></script>    
  <script src="./js/CitydbKmlLayer.js"></script> 
  <script src= "./js/d3.js"></script>
  <script src= "./js/geotiff.js"></script>
  <script src= "./js/jquery.js"></script>
  <script src= "./js/proj4.js"></script>
    
  <style>
     @import url(./ThirdParty/Cesium/Widgets/widgets.css);
      html, body, #cesiumContainer {
          top: 0px;
          left: 0px;
          position: absolute;
          width: 100%;
          height: 100%;
          margin: 0;
          padding: 0;
          overflow: hidden;
          z-index: -1;
      }
      #uiMenu {
          border-radius:5px;
          padding: 10px;
          position:absolute;
          left: 20px;
          font-family: "Arial";
          z-index: 99999;
      }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
   <div id="uiMenu">
   <!--  <button type="button" onclick="addgltfLayers()">add waterbody gltf Layer</button>
    <button type="button" onclick="addkmlLayers()">add waterbody kml Layer</button> -->
     <span>Time Controls: </span><button id="getPrevius" style="margin-top: 5px;">Backward</button> <button id="getNext" style="margin-top: 5px;">Forward</button></br>

  </div>
  <script>
	Cesium.BingMapsApi.defaultKey = 'ApOW9LMkerqWIVSnFauilSeaZyp8df66byy1USCTjgTdMvhb4y1iAhEsUHQfCgzq'
	       
    var s = 51.139942;
    var n = 51.143203;
    var w = 7.366514;
    var e = 7.373476;
  
	var viewer = new Cesium.Viewer('cesiumContainer', {
	   //   terrainExaggeration : 2.0

	});
	var extent = new Cesium.Rectangle.fromDegrees(w,s,e,n);
	viewer.camera.setView({destination: extent})
	
	var webMap = new WebMap3DCityDB(viewer);
	webMap.activateViewChangedEvent(true);
	var scene = viewer.scene;
	var buildingLayer;
	var lotLayer;
	var streetLayer;
 
 
 viewer.flyTo(
    viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/roadal.kml', {
            camera: viewer.camera,
            canvas: viewer.canvas
        })
    ))
  viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/betrieb.kml', {
            camera: viewer.camera,
            canvas: viewer.canvas
        })
    )
     viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/doc.kml', {
            camera: viewer.camera,
            canvas: viewer.canvas
        })
    )
     viewer.dataSources.add(
        Cesium.KmlDataSource.load('./data/pegel.kml', {
            camera: viewer.camera,
            canvas: viewer.canvas
        })
    )
      
      
       	var addgltfLayers = function() {
 
 
 
 gltf= new CitydbKmlLayer({
		 	url : './data/waterbody/pigel_collada_MasterJSON.json'  
           
		});
  
		 webMap.addLayer(gltf);
	 	    console.log(gltf)      

		gltf.registerEventHandler("FINISHLOADING", function(loadedcitydbLayer) {
			loadedcitydbLayer.zoomToStartPosition();
		});		
	};
  viewer.scene.globe.depthTestAgainstTerrain = false;
  viewer.scene.globe.showWaterEffect =true;
	var addkmlLayers = function() {
		kml = new CitydbKmlLayer({
		 
            url : './data/waterbody/pigel_extruded_MasterJSON.json'
		});
		 webMap.addLayer(kml); 
         kml.registerEventHandler("FINISHLOADING", function(loadedcitydbLayer) {
			loadedcitydbLayer.zoomToStartPosition();
		});	
	};	
    
    var terrainProvider = new Cesium.CesiumTerrainProvider({
     url: 'http://localhost/dashboard/cesium/Apps/terraincop'    

 //   url : '//assets.agi.com/stk-terrain/world'
    ,  requestVertexNormals : true  
 
    });
     viewer.terrainProvider = terrainProvider;


    
  

 
 //createCzml() ;
 
var start = Cesium.JulianDate.fromDate(new Date(2015, 1, 01, 00));
var stop = Cesium.JulianDate.addSeconds(start, 360, new Cesium.JulianDate());
//var stop = Cesium.JulianDate.fromDate(new Date(2015, 2, 27, 16));
var middle = Cesium.JulianDate.addSeconds(start, 60, new Cesium.JulianDate());

//Make sure viewer is at the desired time.
viewer.clock.startTime = start.clone();
viewer.clock.stopTime = stop.clone();
viewer.clock.currentTime = start.clone();
viewer.clock.ClockStep = 1;
 
viewer.clock.multiplier = 30;
viewer.timeline.zoomTo(start, stop);
var start = viewer.clock.currentTime;
//var currentTime = Cesium.JulianDate.fromDate(new Date( ));
 var currentTime = start ;
console.log(viewer.clock)
 //var dataSource = Cesium.CzmlDataSource.load(czml);
 
// viewer.dataSources.add(dataSource);
//viewer.zoomTo(dataSource);
 
var positionN=[];
var ellipsoid = Cesium.Ellipsoid.WGS84;
var idList=[];

 czml = './data/simple.czml';
 Cesium.CzmlDataSource.updaters.push(czmlUpdater);

var czmldataSource = Cesium.CzmlDataSource.load(czml);

viewer.dataSources.add(czmldataSource).then(function(data){

var a =positionN.length

        
    var promis = Cesium.sampleTerrain(viewer.terrainProvider, 17, positionN);
        promis.then(function(terrainSamplePositions){ 
            var entities= data.entities;
             for (var i = 0; i < terrainSamplePositions.length; ++i) {
                var BaseHeight = terrainSamplePositions[i].height;//.toFixed(2);
            //         console.log(BaseHeight)

                var entity = entities.getById(idList[i]);
                var cartesianOld = entity.position._value ;       
 //entity.position.getValue( currentTime);        
                var cartesianOldToCartography= ellipsoid.cartesianToCartographic(cartesianOld);
                //var newHeight2 = BaseHeight +1* cartesianOldToCartography.height
                var newHeight2 = 290+ cartesianOldToCartography.height
          //      console.log(parseFloat(cartesianOldToCartography.height).toFixed(4))
                 entity.position.setValue(Cesium.Cartesian3.fromRadians(cartesianOldToCartography.longitude,cartesianOldToCartography.latitude,newHeight2));
                
                var poly2 ={ 
                
                    id : "point"+i,    name : i +"p" , 	position : new Cesium.Cartesian3.fromRadians(cartesianOldToCartography.longitude,cartesianOldToCartography.latitude,newHeight2) , 
                   "point" : {
                   
                 pixelSize:11
      
                        } ,
         }            

       //  entities.add(poly2)  
            }
 
        });
 
}) ;
 
 //node transformation of the model 
 /// change position of the model 
  i=1
  var rasterset = ["1feb","28feb","1sep"];
  
  
 $('#getNext').on('click',function() {
	   
        if(i<rasterset.length-1){ i++ ;
         console.log(viewer.clock.currentTime);
        viewer.clock.currentTime =  Cesium.JulianDate.addSeconds(viewer.clock.currentTime, 60, new Cesium.JulianDate());
  callRaster(rasterset[i])
  }
   
	});
 $('#getPrevius').on('click',function() {
	    
 if(i>0){ i--  
   console.log(viewer.clock.currentTime);
        viewer.clock.currentTime =  Cesium.JulianDate.addSeconds(viewer.clock.currentTime, -60, new Cesium.JulianDate());
     callRaster(rasterset[i])
}
	});
    
   
    
    // on time change
viewer.clock.onTick.addEventListener(function(clock) {
    var entity = viewer.selectedEntity;
 
 //console.log(clock.currentTime,middle)
    if (Cesium.defined(entity)    ) {
  //   viewer.trackedEntity = entity
    var dataSources = viewer.dataSources;
   // console.log(dataSources)
    console.log(entity.model.nodeTransformations.Y_UP_Transform.translation._value.z);
  // console.log(entity.model);
    
    var czmlEntities = dataSources.get(0).entities.values;
   // console.log(czmlEntities)
    // czmlEntities .forEach(function(element) {})
 
}
   if ( Cesium.JulianDate.equals(clock.currentTime,start )){
  //  console.log(clock)
     Cesium.loadWithXhr({
    url : './data/28feb.tif',
    responseType : 'arraybuffer'
}).then(function(response) {
   console.log(response);
  var rasterdata=  geotif(response);
   console.log(rasterdata);
}).otherwise(function(error) { console.log(error);
    // an error occurred
});
   
   
   }
  
//var entity = viewer.selectedEntity;
//  if (!Cesium.defined(entity) ) {  
 
    
});

function callRaster (rastername){
   Cesium.loadWithXhr({
    url : './data/'+ rastername+'.tif',
    responseType : 'arraybuffer'
}).then( loadRasterToMap).otherwise(function(error) { console.log(error);
    // an error occurred
})

}
// call raster for a time and apply to map 
function loadRasterToMap (response) {
       var rasterdata=  geotif(response);
   // console.log(rasterdata);
    var dataSources = viewer.dataSources;
 
     hash=[];
 
    var w1 = Math.floor(rasterdata[2][1]);
    var h1 = Math.floor(rasterdata[2][0]);
 
    var w2 = Math.round(rasterdata[2][1]/(10));
    var h2 = Math.round(rasterdata[2][0]/(10));
    
    var x_ratio=w1/w2
    var    y_ratio=h1/h2; 
    console.log(w1,w2,h1,h2)
    for (var i=0;i<h2;i++){
                for(var j=0;j<w2;j++){
                var px = Math.floor(j*x_ratio) ;
                var py = Math.floor(i*y_ratio) ;
     
                hash[parseInt((i*w2)+j)] = rasterdata[0][1][(py*w1)+px];
                var cellOnOrigin = (i*w2)+j
                var id = "CELL_"+cellOnOrigin;
                
                var entity = dataSources.get(0).entities.getById(id);
                    if( entity){
                       var averageHeight = rasterdata[0][1][(py*w1)+px]
                       var color =  setColor(averageHeight);
                        entity.model.nodeTransformations.Y_UP_Transform.translation = (new Cesium.Cartesian3(0,0,averageHeight) ) ;
                    entity.model.color = color
    
                    }   
                }
        }  
              
 
   
}
//add color to any czml loaded 
  function czmlUpdater(dynamicObject, packet, dynamicObjectCollection, sourceUri) {
        var height = packet.position.cartographicDegrees[2]
      var height2 = packet.model.nodeTransformations.Y_UP_Transform.translation.cartesian[2];
      packet.model.nodeTransformations.Y_UP_Transform.translation.cartesian[2]=  height
    
        var color =  setColor(height);
        color= {"rgba": [255*color.red,255*color.green ,255*color.blue,255* color.alpha]}
        packet.model.color =  color;
        currentPosition = packet.position.cartographicDegrees;
        packet.position.cartographicDegrees = [ currentPosition[0], currentPosition[1],0]
        positionN.push(  new Cesium.Cartographic(Cesium.Math.toRadians(  currentPosition[0]), Cesium.Math.toRadians( currentPosition[1]) ));
        idList.push(packet.id);
      
    }



  function createCzml(){     
     var czml = [{
        "id" : "document",
        "name" : "CZML Point",
        "version" : "1.0"  }];
     var kmlPath = "https://raw.githubusercontent.com/amir-ba/WaterBody-Visualization-/master/HTML5Application/public_html/data/waterbody/Tiles/0/0/pigel_Tile_0_0_collada.kml";
     var kmlFolder= kmlPath.replace(/\/[^\/]+$/, '');
        
    $.get(kmlPath, function(data){

        $(data).find("Placemark").each(function(index, value){
            var that =$(this);
            var id = that.attr( "id" );
            var name = that.find( "name" ).text();
            var locationNode= that.find( "Location" );
            var location = [parseFloat(locationNode.find( "longitude" ).text()),parseFloat(locationNode.find( "latitude" ).text()),parseFloat(locationNode.find( "altitude" ).text())];
            var path =  that.find( "href" ).text();
            if (id){
            
                var packet =  {
                            "id":  name,
                            "name": name,
                            "position": {
                                "cartographicDegrees": location
                            },
                            "model": {
                                "gltf": kmlFolder +"/"+path ,
                                "colorBlendModes": "Replace",
                                "colorBlendAmount": 1 ,
                                "nodeTransformations": { 
                                    "Y_UP_Transform": {
                                            "translation": {
                                                    "cartesian":[0,0,0]}
                                    }
                                }
                                
                            }               
                } 
                czml.push(packet);
            
            }
        });
 console.log(JSON.stringify(czml));

   return czml;
});
}
 

function setColor(height,startHeight,intervals,cssColorArray){
  if(!cssColorArray){cssColorArray =  ["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#f7f7f7","#d1e5f0","#92c5de","#4393c3","#2166ac","#053061","#050861"];  }
  if(!intervals){var interval = 0.03 }
  if(!startHeight){var startHeight = 0.01  }

   // var startHeight= heightIntervals[0];
  //  var interval = heightIntervals[1];
 //   var endHeight= heightIntervals[2];
    var rangeIndex;
    if  ( height<=startHeight){
                rangeIndex =11;
            }else if (height >startHeight && height<=(startHeight+1*interval) ){
                rangeIndex =10;
            }else if (height >(0.03) && height<=(0.05) ){
                rangeIndex =9;
            }else if (height >(0.05)  && height<=(0.06 )){
                rangeIndex =8;
            }else if (height >(0.06)  && height<=(0.08)  ){
                rangeIndex =7;
            }else if (height >(0.08)  && height<=(1)  ){
                rangeIndex =6;
            }else if (height >(1)  && height<=(1.1)  ){
                rangeIndex =5;
            } else if (height >(1)  && height<=(1.5)  ){
                rangeIndex =4;
            }else if (height >(1.5)  && height<=(2)  ){
                rangeIndex =3;
            }else if (height >(2)  && height<=(2.5)  ){
                rangeIndex =2;
            }else if (height >(2.5)  && height<=(3)  ){
                rangeIndex =1;
            }
            else if (height >(3)  ){
                rangeIndex =0;
            }
    var color= new Cesium.Color.fromCssColorString(cssColorArray[rangeIndex]);
 //   console.log(rangeIndex)
    return color;
}

 
  
  function geotif(RR){
 
 
    var tiff = GeoTIFF.parse(RR);
    var image = tiff.getImage();

    var rasters= image.readRasters();
    var tiepoint = image.getTiePoints()[0];
    var pixelScale = image.getFileDirectory().ModelPixelScale;
    var geoTransform = [tiepoint.x, pixelScale[0], 0, tiepoint.y, 0, -1*pixelScale[1]];
    var height = image.getHeight() //geoTransform[1];
    var width = Math.abs( image.getWidth())///geoTransform[5]);
    var invGeoTransform = [-geoTransform[
    0]/geoTransform[1], 1/geoTransform[1],0,-geoTransform[3]/geoTransform[5],0,1/geoTransform[5]];
 return [rasters,geoTransform,[height,width]]
 
 }
  minValue= 2457127
  maxValue= 2557127
 
 function fitRange(num){
             Number.prototype.map = function (in_min, in_max, out_min, out_max) {
                      return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
                                     };
                   return num.map(minValue,maxValue,0,1);//maxValue-minValue);
        
             }
 
</script>
</body>
</html>
